/**
 * Created by Administrator on 2016/9/12.
 */
"use strict";
//const knex = require('./knex').knex;
//const cache = require('../common/cacheAble');
/*const config = require('../config/config');*/
const _ = require('lodash');

class Table {
    constructor(name,knex){
        this.name = name;
        this.knex = knex;
        this.max_insert_len = 500;
        this.max_update_len = 100;
    };

    create(info) { return this.knex(this.name).insert(info);};
    retrieve(uuid) {return this.knex(this.name).select().where('uuid', uuid);};
    update(info) {return this.knex(this.name).update(info).where('uuid', info.uuid);};
    delete(uuid) {
        return this.knex(this.name).delete().where('uuid', uuid);
    };
    query(queryStr, offset, limit, retRaw = '*', orderBy = undefined) {
        if (orderBy) {
            return this.knex(this.name).select(retRaw).whereRaw(queryStr).offset(offset).limit(limit).orderByRaw(orderBy);
        } else {
            return this.knex(this.name).select(retRaw).whereRaw(queryStr).offset(offset).limit(limit);
        }
    };
    queryBy(queryStr,retRaw='*') { return this.knex(this.name).select(retRaw).whereRaw(queryStr);};
    getCount(queryStr) {return this.knex(this.name).whereRaw(queryStr).count('id as count').then(results => results[0].count);}

    *batchCreate(infoList) {
        let curKnex = this.knex;
        let name = this.name;
        let max_insert_len = this.max_insert_len;
        return curKnex.transaction(function (trx) {
            Promise.resolve('start')
                .then(function (pluginResults) {
                    if (infoList.length > max_insert_len)
                    {
                        let singleDatas = _.chunk(infoList,max_insert_len);
                        console.log('Table-->batchCreate seperator batchs:',singleDatas.length);
                        let singleDataInsert = singleDatas.map(singData=>{
                            return curKnex(name).insert(singData).transacting(trx);
                        });
                        return Promise.all(singleDataInsert);
                    }
                    else
                    {
                        return curKnex(name).insert(infoList).transacting(trx);
                    }
                    

                })
                .then(function (raws) {
                        console.log('Table-->  batchCreate success raws :' + JSON.stringify(raws));
                        trx.commit();
                        return "success";
                    })
                    .catch(trx.rollback);
        })
         .then(
                inserts=> {
                    return "ok";
                }
            );
    }



    *batchUpdate(infoList) {
        let curKnex = this.knex;
        let name = this.name;
        return curKnex.transaction(function (trx) {
            Promise.resolve('start')
                .then(function (pluginResults) {
                    let updateReq = infoList.map(info=>{
                        return  curKnex(name).update(info).where('uuid', info.uuid)
                            .transacting(trx);
                    });
                    return Promise.all(updateReq);
                })
                .then(function (raws) {
                    console.log('Table -->  batchUpdate success raws :' + JSON.stringify(raws));
                    trx.commit();
                    return "success";

                })
                .catch(trx.rollback);
        })
            .then(
                inserts=> {
                    return "ok";
                }
            );
    };

    *batchUpdateBySame(uuidList,UpdateObj) {
        let curKnex = this.knex;
        let name = this.name;
        let max_update_len = this.max_update_len;
        return curKnex.transaction(function (trx) {
            Promise.resolve('start')
                .then(function (pluginResults) {
                    if (uuidList.length > max_update_len)
                    {
                        let singleUUIDs = _.chunk(uuidList,max_update_len);
                        console.log('Table-->batchUpdateBySame seperator batchs:',singleUUIDs.length);
                        let singleDataUpdate = singleUUIDs.map(singUUID=>{
                            return  curKnex(name).update(UpdateObj).whereIn('uuid', singUUID)
                                .transacting(trx);
                        });
                        return Promise.all(singleDataUpdate);
                    }
                    else
                    {
                        return  curKnex(name).update(UpdateObj).whereIn('uuid', uuidList)
                            .transacting(trx);
                    }

                })
                .then(function (raws) {
                    console.log('Table -->  batchUpdate success raws :' + JSON.stringify(raws));
                    trx.commit();
                    return "success";

                })
                .catch(trx.rollback);
        })
            .then(
                inserts=> {
                    return "ok";
                }
            );
    };


    *batchDelete(uuidList) {
        let curKnex = this.knex;
        let name = this.name;
        let max_update_len = this.max_update_len;
        return curKnex.transaction(function (trx) {
            Promise.resolve('start')
                .then(function (pluginResults) {
                 return  curKnex(name).delete().whereIn('uuid', uuidList)
                            .transacting(trx);
                })
                .then(function (raws) {
                    console.log('Table -->  batchDelete success raws :' + JSON.stringify(raws));
                    trx.commit();
                    return "success";

                })
                .catch(trx.rollback);
        })
            .then(
                inserts=> {
                    return "ok";
                }
            );
    };




}

//const tableNames = ['users','departments', 'organizations'];
/*
const  tableNames = config.tables;

tableNames.map((name)=>{
    exports[name+'DB']=new Table(name);
});
*/

exports.baseTable = Table;




