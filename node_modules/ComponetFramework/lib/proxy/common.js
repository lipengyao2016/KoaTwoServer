/**
 * Created by Administrator on 2016/9/12.
 */

const errorCodeTable = require('commonutils').errorCodeTable;
const TimeLogger = require('commonutils').TimeLogger.TimeLogger;
const _ = require('lodash');
const co = require('co');

function querySQLGenerator(queryKeys){
    let {exactKeys=[],vagueKeys=[],inKeys=[],DateKeys=[],changeKeys={}} = queryKeys;

    return function(queryJson) {
        let queryCondition = _.clone(queryJson);

        let sqlArray = [];

        let hasUserKeys = [];

        delete  queryCondition.offset;
        delete  queryCondition.limit;

        _.keysIn(queryCondition).map(key=>{
            console.log('key:' + key);
            let value = queryCondition[key];

            //数组。
            if (_.isArray(value)) {
                if (value.length > 0) {
                    let ss = value.map(str => `'${str}'`);
                    let tmpStr = _.join(ss,',');
                    sqlArray.push(`${key} in (${tmpStr})`);
                }
            }
            else if(_.isString(value) )
            {
                if (value.match(new RegExp('(\\[)|(\\])|(\\")')))
                {
                    let timeArray = value.replace(/(\[)|(\])|(\")/g,"").split(',');
                    if (timeArray[0]!=' ' && timeArray[0]!='') { sqlArray.push(`${key} >= '${timeArray[0]}'`);}
                    if (timeArray[1]!=' ' && timeArray[1]!='') { sqlArray.push(`${key} <= '${timeArray[1]}'`);}
                }
                else if ( value.indexOf('*') != -1) {
                    let str = value.replace(/\*/g, '%');
                    sqlArray.push(`${key} like '${str}'`);
                }
                else {
                    sqlArray.push(`${key}='${value}'`);
                }
            }
            else
            {
                sqlArray.push(`${key}=${value}`);
            }


        });






      /*  _.keys(changeKeys).map(key=>{
            queryCondition[changeKeys[key]] = queryCondition[key];
            delete queryCondition[key];
        });


        //精确查询
        exactKeys.map( key =>{
            if(queryCondition[key] && !_.isArray(queryCondition[key])){
                sqlArray.push(`${key}='${queryCondition[key]}'`);
                hasUserKeys.push(key);
            }
        });
        //模糊like查询
        vagueKeys.map( key =>{
            /!** 2017/2/20 判断不是数组时，才进行模糊查询。
             lpy-modifyed  *!/
            if(queryCondition[key] && !_.isArray(queryCondition[key])){

                if (queryCondition[key].indexOf('*') == -1) {
                    sqlArray.push(`${key}='${queryCondition[key]}'`);
                }
                else {
                    let str = queryCondition[key].replace(/\*!/g, '%');
                    sqlArray.push(`${key} like '${str}'`);
                }

                hasUserKeys.push(key);

            }
        });
        //集合in查询
        inKeys.map(key=>{
            if( !_.isUndefined(queryCondition[key]) && hasUserKeys.indexOf(key) < 0){
                let arrayStr = queryCondition[key];

                if (_.isArray(arrayStr)) {
                    if (arrayStr.length > 0) {
                        let ss = arrayStr.map(str => `'${str}'`);
                        let tmpStr = _.join(ss,',');
                        sqlArray.push(`${key} in (${tmpStr})`);
                    }
                }
                else {
                    if(_.isEmpty(queryCondition[key])){
                        sqlArray.push(`${key} is null`);
                    }
                    else {
                        sqlArray.push(`${key}='${queryCondition[key]}'`);
                    }

                }
            }
        });
        //日期时间查询
        DateKeys.map(key=>{
            if(queryCondition[key]){
                let time = queryCondition[key];
                let timeArray = time.replace(/(\[)|(\])|(\")/g,"").split(',');
                if (timeArray[0]!=' ' && timeArray[0]!='') { sqlArray.push(`${key} >= '${timeArray[0]}'`);}
                if (timeArray[1]!=' ' && timeArray[1]!='') { sqlArray.push(`${key} <= '${timeArray[1]}'`);}
            }
        });*/
        //链接所有SQL
        let queryStr = _.join(sqlArray,' and ');
        //console.log(queryStr);
        return queryStr;
    };
}
class Proxy {
    constructor(table,convert2DBInfo, convert2LogicInfo, generateQueryCondition,dateKeys) {
        this.table = table;
        this.convert2DBInfo = convert2DBInfo;
        this.convert2LogicInfo = convert2LogicInfo;
        this.generateQueryCondition = generateQueryCondition;
        this.dateKeys = dateKeys;
    };

    async create(info) {
        let dbInfo = this.convert2DBInfo(info, true);
         await  this.table.create(dbInfo);
        return await this.retrieve(dbInfo.uuid);
    };


    async batchCreate(infoList) {

        let infoObjList =  infoList.map(info=>{
            return this.convert2DBInfo(info,true);
        });

        let results ='';

        if(infoObjList.length > 0)
        {
            results = await this.table.batchCreate(infoObjList);
            return infoObjList;
        }
        else
        {
            return null;
        }

    };

    compareObjAttr(obj1,obj2,exclueKeys)
    {
        let bSame = true;
        for(let key1 of obj1)
        {
            if(!exclueKeys.contains(key1))
            {
                let value1 = obj1[key1];
                if(!(obj2[key1] && obj2[key1] == value1))
                {
                    bSame =false;
                    break;
                }
            }
        }
        return bSame;
    }


    async batchUpdate(infoList,bUpdateSameValue) {

        let infoObjList =  infoList.map(info=>{
            return this.convert2DBInfo(info);
        });

        let results ='';
        let timerLogger = new TimeLogger();

        if(infoObjList.length > 0)
        {

            /** 2017/2/9  判断如果除了UUID,修改时间，其它的更新字段完全一样的话，可以使用批量更新来完成。
             lpy-modifyed  */
            /** 2017/2/20  增加标志字段来区分是否更新同一字段。
             lpy-modifyed  */
            let bUpdateSameKey = bUpdateSameValue;
            let firstObj = infoObjList[0];
            let uuidList = [];

          /*  let index = 0;
            let excludCompareKeys = ['uuid','modifiedAt'];
            timerLogger.startTime();
            for(let infoObj of infoObjList)
            {
                if(index == 0)
                {
                  firstObj = infoObj;
                }
                else
                {
                    if(!this.compareObjAttr(firstObj,infoObj,excludCompareKeys))
                    {
                        bUpdateSameKey = false;
                        break;
                    }
                }
            }

            timerLogger.endTime('compute all attributes for list');*/

            timerLogger.startTime();

            if(bUpdateSameKey)
            {
                uuidList = infoObjList.map(infoObj=>{return infoObj.uuid});
                let updateObj = _.clone(firstObj);
                delete updateObj.uuid;
                results = await this.table.batchUpdateBySame(uuidList,updateObj);
            }
            else
            {
                results = await this.table.batchUpdate(infoObjList);
            }
            timerLogger.endTime(' batchUpdate end.');

            return infoObjList;
        }
        else
        {
            return null;
        }

    };



    async batchDelete(infoList) {

        let uuidList =  infoList.map(info=>{
            return info.uuid;
        });

        let results ='';

        if(uuidList.length > 0)
        {
            results = await this.table.batchDelete(uuidList);
            return true;
        }
        else
        {
            return false;
        }

    };

    async retrieve(uuid) {
        let rows = await this.table.retrieve(uuid);
        if (rows.length === 0) {
            return null;
        }
        else if (rows.length === 1) {
            return this.convert2LogicInfo(rows[0],true,this.dateKeys);
        }
        else {
            let error = new Error();
            error.name = 'InternalError';
            error.status = 409;
            error.code = 7037;
            error.message = errorCodeTable.errorCode2Text(error.code);
            error.description = 'Find much resource.';
            throw error;
        }
    };

    async update(info) {
        let dbInfo = this.convert2DBInfo(info);
        await this.table.update(dbInfo);
        return await this.retrieve(info.uuid);
    };

    async delete (uuid) {
        let ret = await this.table.delete(uuid);
        if(ret === 1){
            return true;
        }
        else {
            let error = new Error();
            error.name = 'Error';
            error.status = 404;
            error.code = 1599;
            error.message = errorCodeTable.errorCode2Text(error.code);
            error.description = 'Find much resource.';
            throw error;
        }
    };

    async list(queryConditions, offset = 0, limit = 25) {

        /** 2016/12/22  缺省按创建时间降序排列。
         lpy-modifyed  */
        if(!queryConditions.orderBy || _.isEmpty(queryConditions.orderBy))
        {
            //queryConditions.orderBy = 'createdAt DESC';
        }

        let rows = await this.table.query(this.generateQueryCondition(queryConditions), offset, limit, '*', queryConditions.orderBy);
        return rows.map(item=>this.convert2LogicInfo(item,true,this.dateKeys),this);
    };

    async listAll(queryConditions){
        let rows = await this.table.queryBy(this.generateQueryCondition(queryConditions), '*');
        return rows.map(item=>this.convert2LogicInfo(item,true,this.dateKeys),this);
    };

    async getCount(queryConditions) {
        return await this.table.getCount(this.generateQueryCondition(queryConditions));
    };


    async exclusiveUpdate(uuid,key,delta,bAdded) {
        let context = this;
        return await new Promise((resolve, reject)=> {
            context.table.knex.transaction(co.wrap(function*(trx) {
                let oldValue = null;
                try {
                    let rows = yield context.table.knex(context.table.name).select().where('uuid', uuid).forUpdate().transacting(trx);
                    let oldData = context.convert2LogicInfo(rows[0]);
                    oldValue = oldData[key];
                    if(bAdded)
                    {
                        oldData[key] += delta;
                    }
                    else
                    {
                        if(oldValue < delta)
                        {
                            throw  new Error('value is no enough');
                        }
                        oldData[key] -= delta;
                    }
                    yield context.table.knex(context.table.name).update(context.convert2DBInfo(oldData)).where('uuid', uuid).transacting(trx);
                    resolve(context.convert2LogicInfo(oldData,true,context.dateKeys));
                }
                catch (error) {
                    trx.rollback();
                    reject(err);
                }
            }));
        });
    }


}

exports.querySQLGenerator = querySQLGenerator;
exports.Proxy = Proxy;